\begin{lstlisting}
module Blackjack
  describe Game do
    describe '#start' do
      it "should show a welcome message" do
        output = mock()
        game = Game.new(output)

        output.expects(:puts).with("Welcome to Blackjack")
        game.start
      end
      it "should promt for the first card" do
        output = mock()
        game = Game.new(output)

        output.expects(:puts).with("New Card?(yes|no)")
        game.start
      end
    end
  end
end
\end{lstlisting}

Die beiden ueberpruefen ob \verb|output| die gewuenschten Ausgaben, ueber die \verb|puts| Methode erhaelt. Die Loesung fuer diese Beispiele kann im Sinne von \TDD in der einfacht denkbaren Variante implementiert werden.
Allerdings gibt es dabei noch ein Problem. Bei Verwendung eines Mocks wie hier in den Beispielen, erwartet das Framework, dass das Mock-Objekt nur die Befehle die mit \ttfamily{expects} definiert wurden erhaehlt.
Eine Loesung dafuer ist die Verwendung von \ttfamily{stub_everything()} anstelle von \ttfamily{mock()}, so werden alle anderen Methodenaufrufe einfach ignoriert.
Sind diese implementiert, sind sowohl die beiden Beispiele als auch das erste Szenario erfolgreich.

Da im Augenblick alle Szenarien und Beispiele "gruen" sind, wird der Code refactoriesiert?. Dabei faellt auf das die beiden ersten Zeilen der RSpec Beispiele gleich sind und somit herausgezogen und einmal in beiden Beispielen verwendet werden kann.

\begin{lstlisting}
describe '#start' do
  before :each do
    @output = stub_everything('output')
    @game = Game.new(@output)
  end
  it "should show a welcome message" do
    @output.expects(:puts).with("Welcome to Blackjack")
    @game.start
  end
  it "should promt for the first card" do
    @output.expects(:puts).with("New Card?(yes|no)")
    @game.start
  end
end
\end{lstlisting}

Der \ttfamily{before} Block wird nun vor jedem Beispiel ausgefuehrt und das \ttfamily{Game} Objekt vorbereitet.
Um das bisherige Ergebnis nun auch in Aktion sehen zu koennen wird nur noch ein kleines Script benloetig, welches ein \ttfamily{Game} Objekt mit \ttfamily{STDOUT}, also der Standardausgabe, erstellt.

\begin{lstlisting}
#!/usr/bin/env ruby
$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)
require 'blackjack'
game = Blackjack::Game.new(STDOUT)
game.start
\end{lstlisting}

Zugegeben fuer den bisherigen Aufwand ist die Ausgabe der beiden Zeilen noch etwas wenig, aber wie so oft zeigen sich die Vorteile oft erst spaeter im Projekt. Schlie-lich musste bis zu diesem Zeitpunkt auch die komplette Teststruktur aufgebaut werden.

Im naechsten Feature soll der Benutzer eine Karte erhalten und den Wert der Karten wird addieren.
\begin{lstlisting}
Feature: Getting a new Blackjack
  In order to be able to get Blackjack
  As a bored student
  I want to get a new card

Background:
 Given I started the game
   And have a score of 0

Scenario: getting an Ace and show its value
 Given the next card in the stack is an "Ace" with value 11
  When I want a new card
  Then I should see "Your Card: Ace"
   And I should see "Your Score: 11"
\end{lstlisting}

Durch das neue Feature sind einige neue Schritte entstanden, deren Gerueste wieder von Cucumber erzeugt werden.
Au-erdem wird mithilfe von \ttfamily{Background} eine Startsituation fuer die restlichen Szenarion des Features geschaffen.

\begin{lstlisting}
Given /^I started the game$/ do
  @game = Blackjack::Game.new(output)
  @game.start
end

Given /^have a score of (\d+)$/ do |score|
  @game.score.should == score.to_i
end
\end{lstlisting}

Der Durchlauf mit Cucumber weist darauf hin, das es bislange noch keine Methode \ttfamily{score} im \ttfamily{@game} Objekt gibt.
Durch die Kennzeichnung der Variable mit \ttfamily{@} als Instanzvariable ermoeglicht es auf Sie ihn mehreren Schritten zuzugreifen.

\begin{lstlisting}
class Game
  attr_reader :score
  def initialize(output)
    @output = output
    @score = 0
  end
  def start
    ...
  end
end
\end{lstlisting}

Mithilfe von \ttfamily{attr_reader} erzeugen wir automatisch eine Methode zum Lesen der \ttfamily{@score} Variable. Diese wird au-erdem im Kontruktor mit \ttfamily{0} initialisiert.
Als naechter Schritt muss ein Stapel von Karten definiert werden und dieser dem aktuellem Spiel uebergeben werden.

\begin{lstlisting}
Given /^the next card in the stack is an "([^"]*)" with value (\d+)$/ do |card, value|
  stack = [{:name => card, :value => value.to_i}]
  @game.stack = stack
end
\end{lstlisting}

Der Stapel wird in Form eines \ttfamily{Array} dargestellt, dabei sind die Karten jeweils als Hash mit Namen und Wert abgelegt.
Zusaetzlich werden ueber \ttfamily{attr_accessor} Reader und Writer fuer die Variable \ttfamily{stack} erstellt.

\begin{lstlisting}
When /^I want a new card$/ do
  @game.new_card
end
\end{lstlisting}

Alle Schritte sind im Feature nun definiert und Cucumber bemerkt, dass \ttfamily{"Your Card: Ace"} nicht in der aktuellen Ausgabe zu finden ist.
Dazu werden wieder Beispiele in RSpec erstellt. Dabei wird hier allerdings uebersprungen das die fehlenden Zeilen direkt ausgegeben werden und stattdessen direkt der Stapel verwendet.

\begin{lstlisting}
it "should get a new stack of cards" do
  @game.expects(:new_stack)
  @game.start
end
it "should show the first card name" do
  stack = [{:name => 'Ace', :value => 11}]
  @game.stubs(:new_stack).returns(stack)
  @output.expects(:puts).with('Your Card: Ace')
  @game.start
end
\end{lstlisting}

\begin{lstlisting}
class Game
  attr_reader :score
  attr_accessor :stack
  def initialize(output)
    @output = output
    @score = 0
  end
  def start
    @output.puts "Welcome to Blackjack"
    @output.puts "New Card?(yes|no)"
    @stack = new_stack
    if @stack
      new_card
    end
  end
  def new_card
    @output.puts "Your Card: #{@stack.first[:name]}"
  end
  def new_stack
  end
end
\end{lstlisting}

Neben dem ersten Beispiel ist nun auch ein weiter Schritt im Szenario erfolgreich. Fuer den fehlenden Schritt erstellen wir ein weiteres Beispiel.

\begin{lstlisting}
it "should show the first cards value" do
  stack = [{:name => 'Ten', :value => 10}]
  @game.stubs(:new_stack).returns(stack)
  @output.expects(:puts).with('Your Score: 10')
  @game.start
end
\end{lstlisting}

Dadurch das wir in diesem Beispiel eine andere Karte verwenden wird auch sichergestellt das die Karte aus dem Stapel verwendet wird.

\begin{lstlisting}
...
def new_card
  @output.puts "Your Card: #{@stack.first[:name]}"
  @output.puts "Your Score: #{@stack.first[:value]}"
end
...
\end{lstlisting}

Wieder ist sowohl Cucumber als auch RSpec mit dem Code zufrieden und bestaetigt das die Implementierung wie gewuenschten funktioniert.




